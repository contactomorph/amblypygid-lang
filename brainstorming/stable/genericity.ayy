
%% Generic parameters are typically defined using square brackets.
%% However, if a generic type has only one generic parameter, the brackets can be omitted.

maybe Opt[String] = !none
%% Equivalent to:
maybe Opt String = !none

complex List[Mutex[Dict[String, Set[Int]]]] = …
%% Equivalent to:
complex List Mutex Dict[String, Set Int] = …

complex = List[Mutex[Dict[String, Set[Int]]]]()
%% Equivalent to:
complex = List Mutex Dict[String, Set Int]()

%% Generic parameter must be declared in following order:
%% - lifetime dependency parameters
%% - constant value parameters
%% - type parameters

%% Lifetime dependency parameters start with «$» followed by a lowercase letter:
type Buffer[$a]

%% Constant value parameters start with «$!» followed by a lowercase letter:
type Array[$!size Int]

%% Generic parameter types must either
%% - start with «$» followed by an uppercase letter:
type Wrapper[$Type]
%% - be a single uppercase letter:
type Box[T]

%% Constant value dependency allows to define types depending on constant values which can either be
%% - literal constant values:
a FixedArray[10 Int] = …
%% - constant items:
b FixedArray[!numberOfItems Int] = …

%% Life-dependency parameters allow to define types depending on the lifetime of other values.

%% The basic case is untyped: the life-dependency parameter does not specify the type of the value it depends on.
%% It can be any and depends on the actual use of the type inside function signatures.
%% No access mode is specified. The access mode is inferred from the use of the type inside function signatures.
type Wrapper[$a] …

%% Below, «a» is frozen as long as the result of «f1» lives
fn f1(a Text => Wrapper[a]) …
%% Below, «b» is jailed as long as the result of «f2» lives
fn f2(mut b Handler => Wrapper[a]) …
%% The access mode is inferred from the parameter declaration. But it can also be cast explicitly to a lesser access mode:
%% Below, «a» is jailed during the call of «f3» and is then frozen as long as the result of «f3» lives
fn f3(mut a Text => Wrapper[a as cst]) …

%% In the typed case, the life-dependency parameter specifies the type of the value it depends on.
%% Again, no access mode is specified. The access mode is inferred from the use of the type inside function signatures.
type TypedWrapper[$a Text] …

%% Below, «a» is frozen as long as the result of «g1» lives
fn g1(a Text => TypedWrapper[a]) …
%% Equivalent to:
fn g1(cst a Text => TypedWrapper[a as cst]) …

%% Below, «a» is only frozen during the call of «g2» and is then monitored as long as the result of «g2» lives
fn g2(a Text => TypedWrapper[a as tag]) …
%% Equivalent to:
fn g2(cst a Text => TypedWrapper[a as tag]) …

%% Below, «a» is jailed as long as the result of «g3» lives
fn g3(mut a Text => TypedWrapper[a]) …
%% Equivalent to:
fn g3(mut a Text => TypedWrapper[a as mut]) …

%% Below, «a» is only jailed during the call of «g4» and is then frozen as long as the result of «g4» lives
fn g4(mut a Text => TypedWrapper[a as cst]) …
%% Below, «a» is only jailed during the call of «g5» and is then monitored as long as the result of «g5» lives
fn g5(mut a Text => TypedWrapper[a as tag]) …

%% Next function is invalid because parameter a has type Nat, not Text and
%% TypedWrapper requires a life-dependency of type Text:
fn invalid(a Nat => TypedWrapper[a]) …

%% Below, all parameters depend on the same variable «$a» of type Text, but with different access modes.
fn u1(w TypedWrapper[tag $a], x TypedWrapper[tag $a]) … %% «$a» cannot be read or written here.
fn u2(w TypedWrapper[cst $a]) … %% «$a» can be read here, but not written. It is frozen at least during the call of «u2».
fn u3(w TypedWrapper[mut $a]) … %% «$a» can be read and written here. It is jailed at least during the call of «u3».
